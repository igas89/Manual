
 + [use strict](#use-strict)  
 + [Переменные (ES5)](#var-es5)
 + [Переменные (ES6)](#var-es6)
 + [Типы данных](#data-type)
     + [typeof](#typeof)
 + [Операторы](#operator)
 + [Операторы сравнения и логические значения](#operators-compare)




# use script <a name='use-strict'></a>  
Для того, чтобы перевести код в режим полного соответствия стандарту ES5, нужно указать специальную директиву use strict.

# Переменные (ES5) <a name='var-es5'></a> 
Переменная состоит из имени и выделенной области памяти, которая ему соответствует.

Для объявления или, другими словами, создания переменной используется ключевое слово **var** 

Константа – это переменная, которая никогда не меняется. Как правило, их называют большими буквами, через подчёркивание. Константы используют вместо строк и цифр, чтобы сделать программу понятнее и избежать ошибок.

# Переменные (ES6) <a name='var-es6'></a> 
В ES-2015 предусмотрены новые способы объявления переменных: через **let** и **const** вместо var.

Переменная, объявленная через **let**, видна только в рамках блока {...}, в котором объявлена. Это, в частности, влияет на объявления внутри if, while или for.

Объявление **const** задаёт константу, то есть переменную, которую нельзя менять. В остальном объявление const полностью аналогично let.

# Типы данных <a name='data-type'></a>  
### number 
Единый тип число используется как для целых, так и для дробных чисел. Существуют специальные числовые значения **Infinity** (бесконечность, например, 1/0) и **NaN** (ошибка вычислений, не равен себе).

### string 
Тип символ не существует, есть только строка.

### boolean 

### null 
Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».

### undefined
Имеет смысл «значение не присвоено». В теории, если в структуре(объекте) полям указать **undefined**, то при переводе её в json они указаны не будут, в отличие, например, от null.

### object

## typeof <a name='typeof'></a> 
Оператор **typeof** возвращает тип аргумента.
+ Синтаксис оператора: typeof x.
+ Синтаксис функции: typeof(x).

```
typeof undefined // "undefined"
typeof 0 // "number"
typeof true // "boolean"
typeof "foo" // "string"
typeof {} // "object"
typeof null // "object"  (то официально признанная ошибка в языке,null – это не объект, а отдельный тип данных)
typeof function(){} // "function"  (функции не являются отдельным базовым типом в JavaScript, а подвидом объектов. Но typeof выделяет функции отдельно, возвращая для них "function".)
```

# Операторы <a name="operators"></a>
Все операторы возвращают значение.

## +
**Бинарный:** Складывает числа, производит конкатенацию строк. Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке.  
**Унарный:** Ничего не делает, есть побочный эффект - преобразование к числу.

## =
Имеет самый низкий приоритет (3), поэтому сначала вычисляется выражение, затем выполняется присвоение. Возможно присваивание по цепочке, значение будет присваиваться справа налево.

## %
Взятие остатка.

## ++, --
Инкремент/декремент - увеличивает/уменьшает значение на 1.  
Инкремент/декремент можно применить только к переменной. Код 5++ даст ошибку.

**Префиксная форма (++i):** возвращает увеличенный результат.  
**Постфиксная форма (i++):** возвращает старое значение до уивличения.  
Инкремент/декремент можно использовать в любых выражениях, При этом он имеет более высокий приоритет и выполняется раньше, чем арифметические операции.

## Побитовые операции
Побитовые операторы рассматривают аргументы как 32-разрядные целые числа и работают на уровне их внутреннего двоичного представления.  
+ AND(и) ( **&** )
+ OR(или) ( **|** )
+ XOR(побитовое исключающее или) ( **^** )
+ NOT(не) ( **~** )
+ LEFT SHIFT(левый сдвиг) ( **<<** )
+ RIGHT SHIFT(правый сдвиг) ( **>>** )
+ ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( **>>>** )

## Сокращенные арифметические операторы с присвоением
Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций.
```
var n = 2;
n *= 3 + 5; // 16  (n = 2 * 8)
```
```
var n = 2;
n += 5; // теперь n=7 (работает как n = n + 5)
n *= 2; // теперь n=14 (работает как n = n * 2)
```
Так можно сделать для операторов +,-,*,/,% и бинарных <<,>>,>>>,&,|,^.

## Оператор запятая
Запятая позволяет перечислять выражения, разделяя их запятой ','. Каждое из них – вычисляется и отбрасывается, за исключением последнего, которое возвращается.  
Запятая – единственный оператор, приоритет которого ниже присваивания.

# Операторы сравнения и логические значения <a name="operators-compare"></a>
**(==)** При сравнении значений разных типов, используется числовое преобразование.  
**(===)** Сравнение с учетом типов данных.

## Сравнение с null и undefined
+ Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё.
+ При преобразовании в число null становится 0, а undefined становится NaN.
Некорректный результат сравнения null с 0:
```
alert( null > 0 ); // false
alert( null == 0 ); // false
alert(null >= 0); // true
```

# Побитовые операторы <a name="bit-operators"></a>
+ Бинарные побитовые операторы: **& | ^ << >> >>>**.  
+ Унарный побитовый оператор один: **~**.  

Как правило, битовое представление числа используется для:  
+ **Округления числа:** (12.34^0) = 12.  
+ **Проверки на равенство -1:** if (~n) { n не -1 }.  
+ Упаковки нескольких битововых значений («флагов») в одно значение. Это экономит память и позволяет проверять наличие комбинации флагов одним оператором &.
+ Других ситуаций, когда нужны битовые маски.

# Метки для break/continue <a name="metki"></a>
Метка имеет вид "имя:", имя должно быть уникальным. Она ставится перед циклом, вот так:  
```
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    var input = prompt('Значение в координатах '+i+','+j, '');
    // если отмена ввода или пустая строка -
    // завершить оба цикла
    if (!input) break outer; // 
  }
}
```
Вызов break outer ищет ближайший внешний цикл с такой меткой и переходит в его конец.  
Директива continue также может быть использована с меткой, в этом случае управление перепрыгнет на следующую итерацию цикла с меткой.