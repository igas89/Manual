# JavaScript <a name='home'></a> 
 + [use strict](#use-strict)  
 + [Переменные (ES5)](#var-es5)
 + [Переменные (ES6)](#var-es6)
 + [Типы данных](#data-type)
     + [typeof](#typeof)
 + [Операторы](#operator)
 + [Операторы сравнения и логические значения](#operators-compare)

 + [Промисы](#promises)




# use script <a name='use-strict'></a>  
Для того, чтобы перевести код в режим полного соответствия стандарту ES5, нужно указать специальную директиву use strict.

# Переменные (ES5) <a name='var-es5'></a> 
Переменная состоит из имени и выделенной области памяти, которая ему соответствует.

Для объявления или, другими словами, создания переменной используется ключевое слово **var** 

Константа – это переменная, которая никогда не меняется. Как правило, их называют большими буквами, через подчёркивание. Константы используют вместо строк и цифр, чтобы сделать программу понятнее и избежать ошибок.

# Переменные (ES6) <a name='var-es6'></a> 
В ES-2015 предусмотрены новые способы объявления переменных: через **let** и **const** вместо var.

Переменная, объявленная через **let**, видна только в рамках блока {...}, в котором объявлена. Это, в частности, влияет на объявления внутри if, while или for.

Объявление **const** задаёт константу, то есть переменную, которую нельзя менять. В остальном объявление const полностью аналогично let.

# Типы данных <a name='data-type'></a>  
### number 
Единый тип число используется как для целых, так и для дробных чисел. Существуют специальные числовые значения **Infinity** (бесконечность, например, 1/0) и **NaN** (ошибка вычислений, не равен себе).

### string 
Тип символ не существует, есть только строка.

### boolean 

### null 
Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».

### undefined
Имеет смысл «значение не присвоено». В теории, если в структуре(объекте) полям указать **undefined**, то при переводе её в json они указаны не будут, в отличие, например, от null.

### object

## typeof <a name='typeof'></a> 
Оператор **typeof** возвращает тип аргумента.
+ Синтаксис оператора: typeof x.
+ Синтаксис функции: typeof(x).

```javascript
typeof undefined // "undefined"
typeof 0 // "number"
typeof true // "boolean"
typeof "foo" // "string"
typeof {} // "object"
typeof null // "object"  (то официально признанная ошибка в языке,null – это не объект, а отдельный тип данных)
typeof function(){} // "function"  (функции не являются отдельным базовым типом в JavaScript, а подвидом объектов. Но typeof выделяет функции отдельно, возвращая для них "function".)
```

# Операторы <a name="operators"></a>
Все операторы возвращают значение.

## +
**Бинарный:** Складывает числа, производит конкатенацию строк. Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке.  
**Унарный:** Ничего не делает, есть побочный эффект - преобразование к числу.

## =
Имеет самый низкий приоритет (3), поэтому сначала вычисляется выражение, затем выполняется присвоение. Возможно присваивание по цепочке, значение будет присваиваться справа налево.

## %
Взятие остатка.

## ++, --
Инкремент/декремент - увеличивает/уменьшает значение на 1.  
Инкремент/декремент можно применить только к переменной. Код 5++ даст ошибку.

**Префиксная форма (++i):** возвращает увеличенный результат.  
**Постфиксная форма (i++):** возвращает старое значение до уивличения.  
Инкремент/декремент можно использовать в любых выражениях, При этом он имеет более высокий приоритет и выполняется раньше, чем арифметические операции.

## Побитовые операции
Побитовые операторы рассматривают аргументы как 32-разрядные целые числа и работают на уровне их внутреннего двоичного представления.  
+ AND(и) ( **&** )
+ OR(или) ( **|** )
+ XOR(побитовое исключающее или) ( **^** )
+ NOT(не) ( **~** )
+ LEFT SHIFT(левый сдвиг) ( **<<** )
+ RIGHT SHIFT(правый сдвиг) ( **>>** )
+ ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( **>>>** )

## Сокращенные арифметические операторы с присвоением
Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций.
```javascript
var n = 2;
n *= 3 + 5; // 16  (n = 2 * 8)
```
```javascript
var n = 2;
n += 5; // теперь n=7 (работает как n = n + 5)
n *= 2; // теперь n=14 (работает как n = n * 2)
```
Так можно сделать для операторов +,-,*,/,% и бинарных <<,>>,>>>,&,|,^.

## Оператор запятая
Запятая позволяет перечислять выражения, разделяя их запятой ','. Каждое из них – вычисляется и отбрасывается, за исключением последнего, которое возвращается.  
Запятая – единственный оператор, приоритет которого ниже присваивания.

# Операторы сравнения и логические значения <a name="operators-compare"></a>
**(==)** При сравнении значений разных типов, используется числовое преобразование.  
**(===)** Сравнение с учетом типов данных.

## Сравнение с null и undefined
+ Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё.
+ При преобразовании в число null становится 0, а undefined становится NaN.
Некорректный результат сравнения null с 0:
```
alert( null > 0 ); // false
alert( null == 0 ); // false
alert(null >= 0); // true
```

# Побитовые операторы <a name="bit-operators"></a>
+ Бинарные побитовые операторы: **& | ^ << >> >>>**.  
+ Унарный побитовый оператор один: **~**.  

Как правило, битовое представление числа используется для:  
+ **Округления числа:** (12.34^0) = 12.  
+ **Проверки на равенство -1:** if (~n) { n не -1 }.  
+ Упаковки нескольких битововых значений («флагов») в одно значение. Это экономит память и позволяет проверять наличие комбинации флагов одним оператором &.
+ Других ситуаций, когда нужны битовые маски.

[^ Вверх](#home) 
# Метки для break/continue <a name="metki"></a>
Метка имеет вид "имя:", имя должно быть уникальным. Она ставится перед циклом, вот так:  
```javascript
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    var input = prompt('Значение в координатах '+i+','+j, '');
    // если отмена ввода или пустая строка -
    // завершить оба цикла
    if (!input) break outer; // 
  }
}
```
Вызов break outer ищет ближайший внешний цикл с такой меткой и переходит в его конец.  
Директива continue также может быть использована с меткой, в этом случае управление перепрыгнет на следующую итерацию цикла с меткой.




[^ Вверх](#home)
# Промисы <a name='promises'></a>

```javascript
let promise = new Promise(function(resolve, reject) {
  // функция-исполнитель (executor)
  // "певец"
});
```

* ```resolve(value)``` — если работа завершилась успешно, с результатом value.  
* ```reject(error)``` — если произошла ошибка, error – объект ошибки.

Исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать ```resolve``` или ```reject```.

У объекта promise, возвращаемого конструктором ```new Promise```, есть внутренние свойства:

* ```state («состояние»)``` — вначале **"pending"** («ожидание»), потом меняется на **"fulfilled"** («выполнено успешно») при вызове resolve или на **"rejected"** («выполнено с ошибкой») при вызове reject.  
* ```result («результат»)``` — вначале **undefined**, далее изменяется на **value** при вызове resolve(value) или на **error** при вызове reject(error).

Свойства ```state``` и ```result``` – это внутренние свойства объекта Promise и прямого доступа к ним нет. Для обработки результата следует использовать методы ```.then```/```.catch```/```.finally```.

<div style="text-align:center">
  <img alt='Жизненный цикл компанента'  src="manual/images/promise.jpg"/>
</div>

Исполнитель должен вызвать что-то одно: ```resolve``` или ```reject```. Состояние промиса может быть изменено только один раз. Если в исполнителе указаны несколько вызовов ```resolve/reject```, то выполнится только первый вызов одной из функций, остальные будут проигнорированы. 

Функция ```resolve/reject``` ожидает только один аргумент (или ни одного). Все дополнительные аргументы будут проигнорированы. Функцию ```reject``` можно выполнить с любым типом аргумента, но лучше всего вызывать с аргументом ```Error```.

Если промис в состоянии ожидания, обработчики в ```.then/catch/finally``` будут ждать его. Однако, если промис уже завершён, то обработчики выполнятся сразу.

## then
```javascript
promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);
```
Функция ```then``` каждый раз возвращает новый объект промиса. Но при этом обработчик может возвращать не именно промис, а любой объект, содержащий метод ```.then```, такие объекты называют **«thenable»**, и этот объект будет обработан как промис.

```javascript
promise.then(
  function(result) { return 4; }  // эквивалентно Promise.resolve(4), state = fulfilled, поэтому следующий then выполнится 
);
```

```javascript
promise.then(
  function(result) { return new Promise(res, rej); }  // state = pending, поэтому следующий then не выполнится, пока не выполниться данный промис 
);
```
Если в ```.then``` прокинуть ```throw```, то следующей выполниться функция ```.catch```.




## catch
Вызов ```.catch(f)``` – это сокращённый, «укороченный» вариант ```.then(null, f)```.
```javascript
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Ошибка!")), 1000);
});

// .catch(f) это тоже самое, что promise.then(null, f)
promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
```
Вокруг функции промиса и обработчиков находится "невидимый try..catch". Если происходит исключение, то оно перехватывается, и промис считается отклонённым с этой ошибкой.

Это работает не только в функции промиса, но и в обработчиках. Если бросить ошибку (throw) из обработчика (.then), то промис будет считаться отклонённым, и управление перейдёт к ближайшему обработчику ошибок.

```javascript
new Promise((resolve, reject) => {
  throw new Error("Ошибка!");
}).catch(alert); // Error: Ошибка!
```
Это происходит для всех ошибок, не только для тех, которые вызваны оператором ```throw```.

Если мы пробросим (throw) ошибку внутри блока ```.catch```, то управление перейдёт к следующему ближайшему обработчику ошибок. А если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик ```.then```.

Если ошибка не обработана с помощью ```.catch()```, то JavaScript-движок отслеживает такие ситуации и генерирует в этом случае глобальную ошибку. В браузере можно поймать такие ошибки, используя событие ```unhandledrejection```.

```javascript
window.addEventListener('unhandledrejection', function(event) {
  // объект события имеет два специальных свойства:
  alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку
  alert(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана
});

new Promise(function() {
  throw new Error("Ошибка!");
}); 
```



## finally
Вызов ```.finally(f)``` похож на ```.then(f, f)```, f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.

```javascript
new Promise((resolve, reject) => {
  /* сделать что-то, что займёт время, и после вызвать resolve/reject */
})
  // выполнится, когда промис завершится, независимо от того, успешно или нет
  .finally(() => остановить индикатор загрузки)
  .then(result => показать результат, err => показать ошибку)
```

* Обработчик, вызываемый из **finally**, не имеет аргументов. В **finally** неизвестно, как был завершён промис.  
* Обработчик **finally** «пропускает» результат или ошибку дальше, к последующим обработчикам.

**finally** не предназначен для обработки результата.

## Цепочка промисов

```javascript
new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000); // (*)

}).then(function(result) { // (**)

  alert(result); // 1
  return result * 2;

}).then(function(result) { // (***)

  alert(result); // 2
  return result * 2;

}).then(function(result) {

  alert(result); // 4
  return result * 2;

});
```

Обработчик ```handler```, переданный в ```.then(handler)```, может вернуть промис. В этом случае дальнейшие обработчики ожидают, пока он выполнится, и затем получают его результат.

## Замена callback на промисы
Промис может иметь только один результат, но колбэк технически может вызываться сколько угодно раз.

```javascript
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));

  document.head.append(script);
}

// использование:
// loadScript('path/script.js', (err, script) => {...})
```
```javascript
let loadScriptPromise = function(src) {
  return new Promise((resolve, reject) => {
    loadScript(src, (err, script) => {
      if (err) reject(err)
      else resolve(script);
    });
  })
}

// использование:
// loadScriptPromise('path/script.js').then(...)
```


## Promise API
## Promise.all
Используется для запуска множества параллельных промисов. 

Метод ```Promise.all``` принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив) и возвращает новый промис.

Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов. 

```javascript
Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
]).then(alert); // когда все промисы выполнятся, результат будет [1,2,3]
// каждый промис даёт элемент массива
```
Gорядок элементов массива ответа в точности соответствует порядку исходных промисов. Даже если первый промис будет выполняться дольше всех, его результат всё равно будет первым в массиве.

**Если любой из промисов завершится с ошибкой, то промис, возвращённый Promise.all, немедленно завершается с этой ошибкой.**


Обычно, Promise.all(...) принимает перебираемый объект промисов (чаще всего массив). Но если любой из этих объектов не является промисом, он передаётся в итоговый массив «как есть».

## Promise.allSettled
Аналогичен Promise.all, но при этом всегда ждёт завершения всех промисов. В массиве результатов будет:

* ```{status:"fulfilled", value:результат}``` для успешных завершений,  
* ```{status:"rejected", reason:ошибка}``` для ошибок.

```javascript
let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://no-such-url'
];

Promise.allSettled(urls.map(url => fetch(url)))
  .then(results => { // (*)
    results.forEach((result, num) => {
      if (result.status == "fulfilled") {
        alert(`${urls[num]}: ${result.value.status}`);
      }
      if (result.status == "rejected") {
        alert(`${urls[num]}: ${result.reason}`);
      }
    });
  });

 // Ответ:
 //[
 // {status: 'fulfilled', value: ...объект ответа...},
 // {status: 'fulfilled', value: ...объект ответа...},
 // {status: 'rejected', reason: ...объект ошибки...}
 //] 
```

Полифилл:
```javascript
if(!Promise.allSettled) {
  Promise.allSettled = function(promises) {
    return Promise.all(promises.map(p => Promise.resolve(p).then(value => ({
      state: 'fulfilled',
      value: value
    }), error => ({
      state: 'rejected',
      reason: error
    }))));
  };
}
```

## Promise.race
Метод похож на **Promise.all**, но ждёт только первый промис, из которого берёт результат (или ошибку), остальные промисы игнорируются.

```javascript
Promise.race([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1
```

## Promise.resolve/reject

* ```Promise.resolve(value)``` создаёт успешно выполненный промис с результатом value. Аналогичен:
```javascript
let promise = new Promise(resolve => resolve(value));
```

* ```Promise.reject(error)``` создаёт промис, завершённый с ошибкой error. Аналогичен:
```javascript
let promise = new Promise((resolve, reject) => reject(error));
```