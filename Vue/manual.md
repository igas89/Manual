# Vue <a name='home'></a> 
<a href="https://ru.vuejs.org/">https://ru.vuejs.org/</a>   
<a href="https://ru.vuejs.org/v2/api/">Актуальное API</a>

***
* [Компоненты](#components)
* [Входные параметры](#params)
* [Модификаторы](#modifycators)
* [Директивы](#directives)
* [Специальные аттрибуты](#spec-attr)
* [Вычисляемые свойства](#computed)
* [Наблюдатели](#watch)
* [Стили](#styles)
* [Отрисовка списков](#for)
* [Обработка событий](#event)
* [Пользовательские события](#users-event)



***
VueJS представляет CLI для установки vue и начала работы с активацией сервера. 
* npm install --global vue-cli

***
 Создания проекта с использованием Webpack
* vue init webpack myproject

***
Запуск
* cd myproject
* npm run dev

***
[^ Вверх](#home)  





# Компоненты <a name="components"></a>

```javascript
// Определяем новый компонент под именем todo-item
Vue.component('todo-item', {
  template: '<li>Это одна задача в списке</li>'
})
```
Теперь его можно использовать в шаблоне другого компонента:

```html
<ol>
  <!-- Создаём экземпляр компонента todo-item -->
  <todo-item></todo-item>
</ol>
```
Когда экземпляр Vue создан, он добавляет все свойства, найденные в опции data, в систему реактивности Vue. Но! Свойства в data будут реактивными, только если они существовали при создании экземпляра. Т.е. необходимо сразу установить начальное значение.

Каждый экземпляр Vue при создании проходит через последовательность шагов инициализации :
1) настраивается наблюдение за данными;
2) компилируется шаблон;
3) монтируется экземпляр в DOM;
4) обновляется DOM при изменении данных.

<img alt='Жизненный цикл компанента' src="manual/images/life.png"/>













[^ Вверх](#home)  






# Входные параметры <a name='params'></a>
При использовании шаблонов в DOM входные параметры в camelCase-стиле в компоненте должны использовать свои эквиваленты в стиле kebab-case (разделённые дефисами).

Указание типа входных параметров:
```javascript
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // или любой другой конструктор
}
```
Для того, чтобы указать Vue, что передается выражение, а не строка, необходимо использовать ```v-bind:```. Это относится к числам, булевым значениям, массивам, объектам.

```html
<!-- Указание входного параметра без значения будет означать `true`. -->
<blog-post is-published></blog-post>

<!-- Несмотря на то, что `false` статическое значение, нам нужен v-bind -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.     -->
<blog-post v-bind:is-published="false"></blog-post>
```

Все входные параметры образуют одностороннюю привязку между дочерним свойством и родительским: когда родительское свойство обновляется — оно будет передаваться дочернему, но не наоборот. Изменение входного параметра может потребоваться в нескольких случая:

1. Входной параметр используется для передачи начального значения. В этом случае лучше всего определить локальное свойство в данных, которое использует значение входного параметра в качестве начального:
```javascript
props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
  }
}
```
2. Входной параметр передаётся как необработанное значение, которое необходимо преобразовать. В этом случае лучше всего определить вычисляемое свойство с использованием входного параметра:

```javascript
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
```
> Но! Объекты и массивы передаются по ссылке, поэтому изменение в дочернем элементе повлияет на данные родительского. В данном случае необходимо сделать копию, например, с помощью reduce или $.extend.

Валидация входных параметров:
```javascript
Vue.component('my-component', {
  props: {
    // Просто проверка типа (`null` и `undefined` проходят проверку для любого типа)
    propA: Number,
    // Несколько допустимых типов
    propB: [String, Number],
    // Обязательное значение строкового типа
    propC: {
      type: String,
      required: true
    },
    // Число со значением по умолчанию
    propD: {
      type: Number,
      default: 100
    },
    // Объект со значением по умолчанию
    propE: {
      type: Object,
      // Для объектов или массивов значения по умолчанию
      // должны возвращаться из функции
      default: function () {
        return { message: 'hello' }
      }
    },
    // Пользовательская функция для валидации
    propF: {
      validator: function (value) {
        // Значение должно соответствовать одной из этих строк
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
})
```
>  Входные параметры валидируются перед созданием экземпляра компонента, поэтому свойства экземпляра (например, data, computed и т.д.) не будут доступны внутри default или функций validator.

Отключить наследование атрибутов можно с помощью 
```javascript
Vue.component('my-component', {
  inheritAttrs: false,
  // ...
})
```
 Cвойство экземпляра ```$attrs``` содержит имена атрибутов и значения, переданные компоненту.
 Опция ```inheritAttrs: false``` не влияет на биндинги style и class.

С помощью ```inheritAttrs: false``` и ```$attrs``` можно вручную определять к какому элементу должны применяться атрибуты, что часто требуется для базовых компонентов:

```javascript
Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  template: `
    <label>
      {{ label }}
      <input
        v-bind="$attrs"
        v-bind:value="value"
        v-on:input="$emit('input', $event.target.value)"
      >
    </label>
  `
})
```

[^ Вверх](#home)  







# Модификаторы <a name='modifycators'></a>

Модификаторы — особые постфиксы, добавляемые после точки, обозначающие, что директива должна быть связана каким-то определённым образом.  

```html
<!-- модификатор .prevent говорит директиве v-on вызвать event.preventDefault() при обработке произошедшего события -->
<form v-on:submit.prevent="onSubmit"> ... </form>
```
  
[^ Вверх](#home)  







# Директивы <a name="directives"></a>

Директивы — это специальные атрибуты с префиксом ```v-```. В качестве значения они принимают одно выражение JavaScript (за исключением v-for). Директива реактивно применяет к DOM изменения при обновлении значения этого выражения. 

Начиная с версии 2.6.0, можно использовать JavaScript-выражение в аргументе директивы, заключив его в квадратные скобки:

```html
<a v-bind:[attributeName]="url"> ... </a>
```

## v-text<a name='v-text'></a> 
Управляет текстовым содержимым, тоже что и интерполяция ```{{ Mustache }}```.
```html
<span v-text="msg"></span>
<!-- то же, что -->
<span>{{msg}}</span>
```
***
## v-html<a name='v-html'></a> 
Управляет HTML-содержимым элемента (innerHTML), т.е. содержимое вставляется как обычный HTML, но при этом не компилируется как шаблон Vue. 
```html
<p>Двойные фигурные скобки: {{ rawHtml }}</p>
<p>Директива v-html: <span v-html="rawHtml"></span></p>
```
Содержимое тега *span* будет заменено значением свойства *rawHtml*, интерпретированного как обычный HTML.  Нельзя использовать ```v-html``` для вложения шаблонов друг в друга, потому что движок шаблонов Vue не основывается на строках. 

>Динамическая отрисовка произвольного HTML-кода на сайте крайне опасна, так как может легко привести к XSS-уязвимостям. Использовать интерполяцию HTML можно только для доверенного кода, и нельзя подставлять туда содержимое, создаваемое пользователями.



## v-if<a name='v-if'></a> 
Осуществляет отрисовку элемента, только если передаваемое выражение истинно. При изменении значения выражения на противоположное, элемент и содержащиеся в нём компоненты и директивы уничтожаются/пересоздаются. Т.е. если передаваемое выражение ложно, то элемент не будет вставлен в DOM. Эта директива также запускает анимационные переходы при изменении условия.    
Совместно могут использоваться директивы: ```v-if```, ```v-else-if```.
```html
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Не A/B/C
</div>
```


## v-show<a name='v-show'></a> 
Переключает CSS-свойство display элемента, в зависимости от того, истинно ли указанное выражение, т.е. элемент всегда есть в DOM. При изменении состояния этой директивы вызываются анимации, заданные в transition.

## v-for<a name='v-for'></a> 
Многократно отрисовывает элемент или блок шаблона, основываясь на переданных данных.

```app4.todos.push({ text: 'Profit' })```  // добавит новый элемент в список.
```html
<div v-for="(item, index) in items"></div>
<div v-for="(val, key) in object"></div>
<div v-for="(val, name, index) in object"></div>
```
При обновлении Vue списка элементов, отображаемого директивой v-for, по умолчанию используется стратегия обновления «на месте». Если порядок элементов массива или объекта изменился, Vue не станет перемещать элементы DOM, а просто обновит каждый элемент «на месте», чтобы он отображал новые данные по соответствующему индексу. 
Чтобы подсказать Vue, как отслеживать идентичность каждого элемента, что позволит переиспользовать и перемещать существующие элементы, укажите уникальный атрибут [```key```](#key).


## v-on <a name='v-on'></a>
 Добавляет к элементу обработчик события. У обычного элемента можно подписаться только на нативные события DOM. У элемента компонента можно подписаться на пользовательские события, вызываемые этим дочерним компонентом.
### Модификаторы:
**.stop** — вызовет event.stopPropagation().  
**.prevent** — вызовет event.preventDefault().  
**.capture** — добавит подписку в режиме capture.  
**.self** — вызовет обработчик только если событие возникло непосредственно на этом элементе.  
**.{keyCode | keyAlias}** — вызывает обработчик только при нажатии определённой клавиши.  
**.native** — подписаться на нативное событие на корневом элементе компонента.  
**.once** — вызовет обработчик не больше одного раза.  
**.left** - (2.2.0) вызов обработчика только по событию нажатия левой кнопки мыши.  
**.right** - (2.2.0) вызов обработчика только по событию нажатия правой кнопки мыши.  
**.middle** - (2.2.0) вызов обработчика только по событию нажатия средней кнопки мыши.  
**.passive** - (2.3.0+) вызов обработчика события DOM с опцией { passive: true }.


```html
<!-- обработчик метода -->
<button v-on:click="doThis"></button>

<!-- динамическое имя события (2.6.0+) -->
<button v-on:[event]="doThis"></button>

<!-- inline-выражение -->
<button v-on:click="doThat('hello', $event)"></button>

<!-- сокращённая запись -->
<button @click="doThis"></button>

<!-- сокращённая запись динамического имени события (2.6.0+) -->
<button @[event]="doThis"></button>

<!-- модификатор stop propagation -->
<button @click.stop="doThis"></button>

<!-- модификатор prevent default -->
<button @click.prevent="doThis"></button>

<!-- модификатор prevent default без дополнительных действий -->
<form @submit.prevent></form>

<!-- цепочка из модификаторов -->
<button @click.stop.prevent="doThis"></button>

<!-- модификатор клавиши keyAlias -->
<input @keyup.enter="onEnter">

<!-- модификатор клавиши keyCode -->
<input @keyup.13="onEnter">

<!-- обработчик метода будет вызван не больше одного раза -->
<button v-on:click.once="doThis"></button>

<!-- синтаксис объекта (2.4.0+) -->
<button v-on="{ mousedown: doThis, mouseup: doThat }"></button>
```
Подписка на пользовательское событие в дочернем элементе (обработчик вызывается, когда дочерний элемент вызывает “my-event”):
```html
<my-component @my-event="handleThis"></my-component>

<!-- inline-выражение -->
<my-component @my-event="handleThis(123, $event)"></my-component>

<!-- подписываемся на нативное событие в компоненте -->
<my-component @click.native="onClick"></my-component>
```



## v-bind <a name='v-bind'></a>
Динамически связывает атрибуты тега или входной параметр компонента с выражением. При использовании с атрибутами class и style поддерживает массивы и объекты в качестве значений.

```html
<!-- связывание атрибута -->
<img v-bind:src="imageSrc">

<!-- динамическое имя атрибута (2.6.0+) -->
<button v-bind:[key]="value"></button>

<!-- сокращённая запись -->
<img :src="imageSrc">

<!-- сокращённая запись для динамического имени атрибута (2.6.0+) -->
<button :[key]="value"></button>

<!-- поддержка конкатенации строк -->
<img :src="'/path/to/images/' + fileName">

<!-- связывание CSS-класса -->
<div :class="{ red: isRed }"></div>
<div :class="[classA, classB]"></div>
<div :class="[classA, { classB: isB, classC: isC }]">

<!-- связывание локального стиля -->
<div :style="{ fontSize: size + 'px' }"></div>
<div :style="[styleObjectA, styleObjectB]"></div>

<!-- связывание с объектом, содержащим атрибуты -->
<div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>

<!-- связывание с атрибутами DOM при указании модификатора -->
<div v-bind:text-content.prop="text"></div>

<!-- связывание входного параметра. "prop" должен быть определён в my-component. -->
<my-component :prop="someThing"></my-component>

<!-- передача всех входных параметров компонента в child-component -->
<child-component v-bind="$props"></child-component>

<!-- XLink -->
<svg><a :xlink:special="foo"></a></svg>
```

## v-model <a name='v-model'></a>
Двусторонним образом связывает элемент ввода данных или компонент с переменной. Используется только с ```<input>```, ```<textarea>```, ```<select>``` и компонентами.

```v-model``` игнорирует начальное значение атрибутов **value**, **checked** или **selected** на любых элементах форм. Данные экземпляра Vue всегда считаются источником истины. Начальное значение необходимо объявить на стороне JavaScript, внутри опции ```data``` компонента.

Внутренне ```v-model``` использует разные свойства и генерирует разные события для различных элементов ввода:

* элементы для ввода текста и многострочного текста используют свойство value и событие input;  
* чекбоксы и радиокнопки используют свойство checked и событие change;  
* выпадающие списки используют свойство value и событие change.

Сама директива делает тоже самое, что и:
```html
<input
  v-bind:value="searchText"
  v-on:input="searchText = $event.target.value"
>
```
Т.е. **value** связывается со значением, которому присваивается введенное значение по событию```input```.


### Использование на компоненте
При использовании на компоненте ```v-model``` делает следующее:

```html
<custom-input
  v-bind:value="searchText"
  v-on:input="searchText = $event"
></custom-input>
```
Чтобы это действительно работало, элемент ```<input>``` внутри компонента должен:

* Привязывать значение атрибута **value** к входному параметру **value**;  
* По событию **input** генерировать собственное пользовательское событие **input** с новым значением; 

```html
 <input
      v-bind:value="value"
      v-on:input="$emit('input', $event.target.value)"
    >
```
теперь v-model будет прекрасно работать с этим компонентом:

```html
<custom-input v-model="searchText"></custom-input>
```

### Модификаторы:
**.lazy** — подписаться на события change, а не input.  
**.number** — приводить корректную введённую строку к числу.  
**.trim** — удалять пробелы в начале и в конце введённой строки.


## v-slot <a name='v-slot'></a>
Указывает именованные слоты или слоты с входными параметрами.

```html
<!-- Именованные слоты -->
<base-layout>
  <template v-slot:header>
    Содержимое заголовка
  </template>

  Содержимое слота по умолчанию

  <template v-slot:footer>
    Содержимое подвала
  </template>
</base-layout>

<!-- Именованный слот с входными параметрами -->
<infinite-scroll>
  <template v-slot:item="slotProps">
    <div class="item">
      {{ slotProps.item.text }}
    </div>
  </template>
</infinite-scroll>

<!-- Слот по умолчанию с входными параметрами, с использованием деструктурирования -->
<mouse-position v-slot="{ x, y }">
  Позиция курсора: {{ x }}, {{ y }}
</mouse-position>
```

## v-pre <a name='v-pre'></a>
Пропустить компиляцию для этого элемента и всех его потомков. Вы можете использовать это для отображения необработанных тегов {{}}. Кроме того, пропуск большого количества элементов может ускорить компиляцию.

```html
<span v-pre>{{ эта часть не будет скомпилирована }}</span>
```

## v-cloak <a name='v-cloak'></a>
Эта директива останется на элементе до тех пор, пока связанный с ним экземпляр Vue не закончит компиляцию. В сочетании с CSS-правилом ```[v-cloak] { display: none }``` этой директивой можно скрывать нескомпилированные шаблоны до тех пор, пока экземпляр Vue не будет готов.

```css
[v-cloak] {
  display: none;
}
```

```html
<div v-cloak>
  {{ message }}
</div>
```

## v-once <a name='v-once'></a>
Однократно отрисовывает элемент или компонент. При повторной отрисовке он, а также все его потомки, рассматриваются как статический контент и пропускаются. Это поможет увеличить производительность обновлений.

```html
<span v-once>Это никогда не изменится: {{msg}}</span>
```

[^ Вверх](#home)  


# Специальные аттрибуты <a name='spec-attr'></a>

## key <a name='key'></a>

***









[^ Вверх](#home)  
# Вычисляемые свойства <a name='computed'></a>

Вычисляемые свойства кэшируются, основываясь на своих реактивных зависимостях. 


Вычисляемое свойство пересчитывается лишь тогда, когда изменится одна из его реактивных зависимостей. 

```html
<div id="demo">{{ fullName }}</div>
```

```javascript
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  },
computed: {
  fullName: {
    // геттер:
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // сеттер:
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
})
```
При изменении this.firstName или this.lastName будет вызван геттер.  
Запись vm.fullName = 'Иван Иванов' вызовет сеттер, и vm.firstName и vm.lastName будут соответствующим образом обновлены.

# Наблюдатели <a name='watch'></a>

Эта возможность полезна для «дорогих» или асинхронных операций, выполняемых в ответ на изменение данных.
Пример использования, но в данном случае лучше использовать вычисляемые свойства.
```html
<div id="demo">{{ fullName }}</div>
```
```javascript
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  },
  watch: {
    firstName: function (val) {
      this.fullName = val + ' ' + this.lastName
    },
    lastName: function (val) {
      this.fullName = this.firstName + ' ' + val
    }
  }
})
```

[^ Вверх](#home)  
# Стили <a name='styles'></a>

Для динамической установки или удаления CSS-классов можно передавать объект в директиву v-bind:class:   
```html
<!--  Наличие класса active будет определяться истинностью параметра isActiveю. -->
<div v-bind:class="{ active: isActive }"></div>
```
v-bind:class можно использовать совместно с обычным атрибутом class:
```html
<div
  class="static"
  v-bind:class="{ active: isActive, 'text-danger': hasError }"
></div>
```
В v-bind:class можно передать и массив:
```html
<div v-bind:class="[activeClass, errorClass]"></div>
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
```
```javascript
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
```

### inline-стили
Объектная запись для v-bind:style является объектом JavaScript.
```html
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
```
```javascript
data: {
  activeColor: 'red',
  fontSize: 30
}
```
Можно использовать и вычисляемые свойства, возвращающие объекты стилей.

[^ Вверх](#home)  
# Условная отрисовка <a name='if'></a>

> Псевдоэлемент ```<template>``` служит невидимой обёрткой и сам в результатах отрисовки не появляется.

Блок будет отображаться только в том случае, если выражение директивы возвращает значение, приводимое к true.

```html
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Не A/B/C
</div>
```

**v-else**, **v-else-if** должен следовать сразу за элементом с **v-if** или **v-else-if**.

### v-show <a name='v-show'></a>

```html
<h1 v-show="ok">Привет!</h1>
```
Разница в том, что элемент с v-show будет всегда оставаться в DOM, а изменяться будет лишь свойство display в его параметрах CSS.

**v-show** не работает на элементе ```<template>``` и не работает с **v-else**.

[^ Вверх](#home)  
# Отрисовка списков <a name='for'></a>

```html
<ul id="example-2">
  <li v-for="(item, index) in items">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  </li>
</ul>
```
```javascript
var example2 = new Vue({
  el: '#example-2',
  data: {
    parentMessage: 'Родитель',
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
```
Вместо **in** разделителем можно использовать **of**, как в итераторах JavaScript.

**v-for** можно также использовать для итерирования по свойствам объекта:  
```html
<div v-for="(value, name, index) in object">
  {{ index }}. {{ name }}: {{ value }}
</div>
```
Чтобы подсказать Vue, как отслеживать идентичность каждого элемента, что позволит переиспользовать и перемещать существующие элементы, необходимо указать уникальный атрибут key для каждого элемента:
```html
<div v-for="item in items" v-bind:key="item.id">
  <!-- содержимое -->
</div>
```
Из-за ограничений JavaScript, Vue не способен отследить следующие изменения в массиве:
* Прямую установку элемента по индексу: ```vm.items[indexOfItem] = newValue``` -> ```Vue.set(vm.items, indexOfItem, newValue)```
* Явное изменение длины массива: ```vm.items.length = newLength``` -> ```vm.items.splice(newLength)```
* Vue не может обнаружить добавление или удаление свойств, для добавления свойств можно использовать ```Vue.set```


[^ Вверх](#home)  
# Обработка событий <a name='event'></a>
Иногда в inline-обработчиках необходим доступ к оригинальному событию DOM. Его можно передать в метод, используя специальную переменную $event:
```html
<button v-on:click="warn('Форма не может быть отправлена.', $event)">
  Отправить
</button>
```
```javascript
// ...
methods: {
  warn: function (message, event) {
    // теперь у нас есть доступ к нативному событию
    if (event) event.preventDefault()
    alert(message)
  }
}
```
 Vue предоставляет модификаторы событий для v-on, которые указываются как постфиксы и отделяются точкой: *.stop, 
.prevent, 
.capture, 
.self, 
.once, 
.passive*.

```html
<!-- событие click не будет всплывать дальше -->
<a v-on:click.stop="doThis"></a>

<!-- событие submit больше не будет перезагружать страницу -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- модификаторы можно объединять в цепочки -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- и использовать без указания метода-обработчика -->
<form v-on:submit.prevent></form>

<!-- можно отслеживать события в режиме capture, т.е. событие, нацеленное -->
<!-- на внутренний элемент, обрабатывается здесь до обработки этим элементом -->
<div v-on:click.capture="doThis">...</div>

<!-- вызов обработчика только в случае наступления события непосредственно -->
<!-- на данном элементе (то есть не на дочернем компоненте) -->
<div v-on:click.self="doThat">...</div>
```
  
### Модификаторы клавиш
Можно использовать любые допустимые имена клавиш, предоставляемые через KeyboardEvent.key в качестве модификаторов, именуя их в kebab-case.
```html
<input v-on:keyup.page-down="onPageDown">
```

Модификатор ```.exact``` позволяет контролировать точную комбинацию системных модификаторов, необходимых для запуска события.

```html
<!-- сработает, даже если Alt или Shift также нажаты -->
<button @click.ctrl="onClick">A</button>

<!-- сработает, только когда нажат Ctrl и не нажаты никакие другие клавиши -->
<button @click.ctrl.exact="onCtrlClick">A</button>

<!-- сработает, только когда не нажаты никакие системные модификаторы -->
<button @click.exact="onClick">A</button>
```

### Модификаторы клавиш мыши
*.left, 
.right, 
.middle*


[^ Вверх](#home)
# Пользовательские события <a name='users-event'></a>

Всегда использовать kebab-case для имён событий.

По умолчанию ```v-model``` на компоненте использует входной параметр ```value``` и событие ```input```.

```javascript
Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    <input
      type="checkbox"
      v-bind:checked="checked"
      v-on:change="$emit('change', $event.target.checked)"
    >
  `
})
```
Теперь, когда используем ```v-model``` на этом компоненте:
```html
<base-checkbox v-model="lovingVue"></base-checkbox>
```
Значение lovingVue будет передано во входном параметре checked. А обновляться свойство lovingVue будет когда ```<base-checkbox>``` сгенерирует событие change с новым значением. При этом нужно объявлять входной параметр ```checked``` в опции ```props``` компонента.